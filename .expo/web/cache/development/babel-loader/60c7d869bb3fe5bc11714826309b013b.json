{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport * as helpers from \"./helpers\";\nexport default function createCompatNavigationProp(navigation, state, context, _isFirstRouteInParent) {\n  var _state$params;\n  context.parent = context.parent || {};\n  context.subscriptions = context.subscriptions || {\n    didFocus: new Map(),\n    didBlur: new Map(),\n    refocus: new Map()\n  };\n  return _objectSpread(_objectSpread(_objectSpread({}, navigation), Object.entries(helpers).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      name = _ref2[0],\n      method = _ref2[1];\n    if (name in navigation) {\n      acc[name] = function () {\n        return navigation.dispatch(method.apply(void 0, arguments));\n      };\n    }\n    return acc;\n  }, {})), {}, {\n    original: navigation,\n    addListener: function addListener(type, callback) {\n      var unsubscribe;\n      switch (type) {\n        case 'willFocus':\n          unsubscribe = navigation.addListener('focus', callback);\n          break;\n        case 'willBlur':\n          unsubscribe = navigation.addListener('blur', callback);\n          break;\n        case 'didFocus':\n          {\n            var listener = function listener() {\n              if (navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('transitionEnd', listener);\n            context.subscriptions.didFocus.set(callback, unsubscribe);\n            break;\n          }\n        case 'didBlur':\n          {\n            var _listener = function _listener() {\n              if (!navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('transitionEnd', _listener);\n            context.subscriptions.didBlur.set(callback, unsubscribe);\n            break;\n          }\n        case 'refocus':\n          {\n            var _listener2 = function _listener2() {\n              if (navigation.isFocused()) {\n                callback();\n              }\n            };\n\n            unsubscribe = navigation.addListener('tabPress', _listener2);\n            context.subscriptions.refocus.set(callback, unsubscribe);\n            break;\n          }\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n        default:\n          unsubscribe = navigation.addListener(type, callback);\n      }\n      var subscription = function subscription() {\n        return unsubscribe();\n      };\n      subscription.remove = unsubscribe;\n      return subscription;\n    },\n    removeListener: function removeListener(type, callback) {\n      context.subscriptions = context.subscriptions || {};\n      switch (type) {\n        case 'willFocus':\n          navigation.removeListener('focus', callback);\n          break;\n        case 'willBlur':\n          navigation.removeListener('blur', callback);\n          break;\n        case 'didFocus':\n          {\n            var unsubscribe = context.subscriptions.didFocus.get(callback);\n            unsubscribe === null || unsubscribe === void 0 ? void 0 : unsubscribe();\n            break;\n          }\n        case 'didBlur':\n          {\n            var _unsubscribe = context.subscriptions.didBlur.get(callback);\n            _unsubscribe === null || _unsubscribe === void 0 ? void 0 : _unsubscribe();\n            break;\n          }\n        case 'refocus':\n          {\n            var _unsubscribe2 = context.subscriptions.refocus.get(callback);\n            _unsubscribe2 === null || _unsubscribe2 === void 0 ? void 0 : _unsubscribe2();\n            break;\n          }\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n        default:\n          navigation.removeListener(type, callback);\n      }\n    },\n    state: {\n      key: state.key,\n      routeName: state.name,\n      params: (_state$params = state.params) !== null && _state$params !== void 0 ? _state$params : {},\n      get index() {\n        var _state$state;\n\n        if (state.index !== undefined) {\n          return state.index;\n        }\n        console.warn(\"Looks like you are using 'navigation.state.index' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'index' property in the child navigation state.\");\n\n        return (_state$state = state.state) === null || _state$state === void 0 ? void 0 : _state$state.index;\n      },\n      get routes() {\n        var _state$state2;\n\n        if (state.routes !== undefined) {\n          return state.routes;\n        }\n        console.warn(\"Looks like you are using 'navigation.state.routes' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'routes' property in the child navigation state.\");\n\n        return (_state$state2 = state.state) === null || _state$state2 === void 0 ? void 0 : _state$state2.routes;\n      }\n    },\n    getParam: function getParam(paramName, defaultValue) {\n      var params = state.params;\n      if (params && paramName in params) {\n        return params[paramName];\n      }\n      return defaultValue;\n    },\n    isFirstRouteInParent: function isFirstRouteInParent() {\n      if (typeof _isFirstRouteInParent === 'boolean') {\n        return _isFirstRouteInParent;\n      }\n      var _ref3 = 'getState' in navigation ? navigation.getState() : navigation.dangerouslyGetState(),\n        routes = _ref3.routes;\n      return routes[0].key === state.key;\n    },\n    dangerouslyGetParent: function dangerouslyGetParent() {\n      var parent = 'getParent' in navigation ? navigation.getParent() : navigation.dangerouslyGetParent();\n      if (parent) {\n        return createCompatNavigationProp(parent, 'getState' in navigation ? navigation.getState() : navigation.dangerouslyGetState(), context.parent);\n      }\n      return undefined;\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["helpers","createCompatNavigationProp","navigation","state","context","isFirstRouteInParent","parent","subscriptions","didFocus","Map","didBlur","refocus","Object","entries","reduce","acc","name","method","dispatch","original","addListener","type","callback","unsubscribe","listener","isFocused","set","Error","subscription","remove","removeListener","get","key","routeName","params","index","undefined","console","warn","_state$state","routes","_state$state2","getParam","paramName","defaultValue","getState","dangerouslyGetState","dangerouslyGetParent","getParent"],"sources":["createCompatNavigationProp.tsx"],"sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  ParamListBase,\n  NavigationProp,\n  RouteProp,\n} from '@react-navigation/native';\nimport * as helpers from './helpers';\nimport type { CompatNavigationProp } from './types';\n\ntype EventName =\n  | 'action'\n  | 'willFocus'\n  | 'willBlur'\n  | 'didFocus'\n  | 'didBlur'\n  | 'refocus';\n\nexport default function createCompatNavigationProp<\n  NavigationPropType extends NavigationProp<ParamListBase>,\n  ParamList extends ParamListBase = NavigationPropType extends NavigationProp<\n    infer P,\n    any,\n    any,\n    any,\n    any\n  >\n    ? P\n    : ParamListBase\n>(\n  navigation: NavigationPropType,\n  state:\n    | (RouteProp<ParamList, keyof ParamList> & {\n        state?: NavigationState | PartialState<NavigationState>;\n      })\n    | NavigationState\n    | PartialState<NavigationState>,\n  context: Record<string, any>,\n  isFirstRouteInParent?: boolean\n): CompatNavigationProp<NavigationPropType> {\n  context.parent = context.parent || {};\n  context.subscriptions = context.subscriptions || {\n    didFocus: new Map<() => void, () => void>(),\n    didBlur: new Map<() => void, () => void>(),\n    refocus: new Map<() => void, () => void>(),\n  };\n\n  return {\n    ...navigation,\n    ...Object.entries(helpers).reduce<{\n      [key: string]: (...args: any[]) => void;\n    }>((acc, [name, method]: [string, Function]) => {\n      if (name in navigation) {\n        acc[name] = (...args: any[]) => navigation.dispatch(method(...args));\n      }\n\n      return acc;\n    }, {}),\n    original: navigation,\n    addListener(type: EventName, callback: () => void) {\n      let unsubscribe: () => void;\n\n      switch (type) {\n        case 'willFocus':\n          unsubscribe = navigation.addListener('focus', callback);\n          break;\n        case 'willBlur':\n          unsubscribe = navigation.addListener('blur', callback);\n          break;\n        case 'didFocus': {\n          const listener = () => {\n            if (navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('transitionEnd', listener);\n          context.subscriptions.didFocus.set(callback, unsubscribe);\n          break;\n        }\n        case 'didBlur': {\n          const listener = () => {\n            if (!navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('transitionEnd', listener);\n          context.subscriptions.didBlur.set(callback, unsubscribe);\n          break;\n        }\n        case 'refocus': {\n          const listener = () => {\n            if (navigation.isFocused()) {\n              callback();\n            }\n          };\n\n          // @ts-expect-error: this event may not exist in this navigator\n          unsubscribe = navigation.addListener('tabPress', listener);\n          context.subscriptions.refocus.set(callback, unsubscribe);\n          break;\n        }\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n        default:\n          unsubscribe = navigation.addListener(type, callback);\n      }\n\n      const subscription = () => unsubscribe();\n\n      subscription.remove = unsubscribe;\n\n      return subscription;\n    },\n    removeListener(type: EventName, callback: () => void) {\n      context.subscriptions = context.subscriptions || {};\n\n      switch (type) {\n        case 'willFocus':\n          navigation.removeListener('focus', callback);\n          break;\n        case 'willBlur':\n          navigation.removeListener('blur', callback);\n          break;\n        case 'didFocus': {\n          const unsubscribe = context.subscriptions.didFocus.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'didBlur': {\n          const unsubscribe = context.subscriptions.didBlur.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'refocus': {\n          const unsubscribe = context.subscriptions.refocus.get(callback);\n          unsubscribe?.();\n          break;\n        }\n        case 'action':\n          throw new Error(\"Listening to 'action' events is not supported.\");\n        default:\n          navigation.removeListener(type, callback);\n      }\n    },\n    state: {\n      key: state.key,\n      // @ts-expect-error\n      routeName: state.name,\n      // @ts-expect-error\n      params: state.params ?? {},\n      get index() {\n        // @ts-expect-error\n        if (state.index !== undefined) {\n          // @ts-expect-error\n          return state.index;\n        }\n\n        console.warn(\n          \"Looks like you are using 'navigation.state.index' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'index' property in the child navigation state.\"\n        );\n\n        // @ts-expect-error\n        return state.state?.index;\n      },\n      get routes() {\n        // @ts-expect-error\n        if (state.routes !== undefined) {\n          // @ts-expect-error\n          return state.routes;\n        }\n\n        console.warn(\n          \"Looks like you are using 'navigation.state.routes' in your code. Accessing child navigation state for a route is not safe and won't work correctly. You should refactor it not to access the 'routes' property in the child navigation state.\"\n        );\n\n        // @ts-expect-error\n        return state.state?.routes;\n      },\n    },\n    getParam<T extends keyof ParamList>(\n      paramName: T,\n      defaultValue: ParamList[T]\n    ): ParamList[T] {\n      // @ts-expect-error\n      const params = state.params;\n\n      if (params && paramName in params) {\n        return params[paramName];\n      }\n\n      return defaultValue;\n    },\n    isFirstRouteInParent(): boolean {\n      if (typeof isFirstRouteInParent === 'boolean') {\n        return isFirstRouteInParent;\n      }\n\n      const { routes } =\n        'getState' in navigation\n          ? navigation.getState()\n          : navigation.dangerouslyGetState();\n\n      return routes[0].key === state.key;\n    },\n    dangerouslyGetParent() {\n      const parent =\n        'getParent' in navigation\n          ? navigation.getParent()\n          : navigation.dangerouslyGetParent();\n\n      if (parent) {\n        return createCompatNavigationProp(\n          parent,\n          'getState' in navigation\n            ? navigation.getState()\n            : navigation.dangerouslyGetState(),\n          context.parent\n        );\n      }\n\n      return undefined;\n    },\n  } as any;\n}\n"]},"metadata":{},"sourceType":"module"}